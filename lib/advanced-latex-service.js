const fs = require("fs").promises;
const path = require("path");
const { spawn } = require("child_process");
const fetch = require("node-fetch");

class AdvancedLatexService {
  constructor() {
    this.methods = {
      LOCAL_DOCKER: "local_docker",
    };

    this.fallbackOrder = [this.methods.LOCAL_DOCKER];
  }

  /**
   * Main compilation method - Docker only
   */
  async compileToPDF(latexCode, filename = "resume", preferredMethod = null) {
    console.log("🔄 Starting Docker LaTeX compilation...");

    try {
      console.log(`🔄 Trying method: ${this.methods.LOCAL_DOCKER}`);
      const result = await this.compileWithMethod(
        this.methods.LOCAL_DOCKER,
        latexCode,
        filename
      );

      if (result.success) {
        console.log(`✅ Success with method: ${this.methods.LOCAL_DOCKER}`);
        return { ...result, method: this.methods.LOCAL_DOCKER };
      }
    } catch (error) {
      console.log(`❌ Docker compilation failed:`, error.message);
      throw new Error(
        "Docker LaTeX compilation failed. We're sorry, but we couldn't generate your PDF preview."
      );
    }

    throw new Error(
      "Docker LaTeX compilation failed. We're sorry, but we couldn't generate your PDF preview."
    );
  }

  /**
   * Method 1: Docker-based LaTeX compilation (Best Quality)
   */
  async compileWithDocker(latexCode, filename) {
    try {
      // Check if Docker is available
      await this.checkDockerAvailability();

      // Create temporary files
      const tempDir = path.join(__dirname, "../temp");
      await fs.mkdir(tempDir, { recursive: true });

      const texFile = path.join(tempDir, `${filename}.tex`);
      const pdfFile = path.join(tempDir, `${filename}.pdf`);

      await fs.writeFile(texFile, latexCode);

      // Run LaTeX compilation in Docker
      const dockerResult = await this.runDockerLatex(tempDir, filename);

      if (dockerResult.success) {
        const pdfBuffer = await fs.readFile(pdfFile);

        // Clean up
        await this.cleanupTempFiles(tempDir, filename);

        return {
          success: true,
          pdfBuffer,
          size: pdfBuffer.length,
          contentType: "application/pdf",
          quality: "overleaf-equivalent",
        };
      }

      throw new Error(dockerResult.error);
    } catch (error) {
      throw new Error(`Docker compilation failed: ${error.message}`);
    }
  }

  // Helper methods
  async compileWithMethod(method, latexCode, filename) {
    // Pre-process LaTeX code to fix common AI-generated issues
    const cleanedLatexCode = this.cleanLatexCode(latexCode);

    switch (method) {
      case this.methods.LOCAL_DOCKER:
        return await this.compileWithDocker(cleanedLatexCode, filename);
      default:
        throw new Error(`Unknown compilation method: ${method}`);
    }
  }

  /**
   * Clean and fix common LaTeX code issues generated by AI
   */
  cleanLatexCode(latexCode) {
    console.log("🧹 Cleaning LaTeX code for compilation...");

    let cleaned = latexCode;

    // Fix common titlespacing issues
    cleaned = cleaned.replace(
      /\\titlespacing\{\\section\*\}/g,
      "\\titlespacing*{\\section}"
    );
    cleaned = cleaned.replace(
      /\\titlespacing\{\\subsection\*\}/g,
      "\\titlespacing*{\\subsection}"
    );

    // Ensure proper package order
    const packages = [];
    const packageRegex = /\\usepackage(\[[^\]]*\])?\{([^}]+)\}/g;
    let match;

    // Extract all packages
    while ((match = packageRegex.exec(cleaned)) !== null) {
      packages.push(match[0]);
    }

    // Remove all package declarations
    cleaned = cleaned.replace(/\\usepackage(\[[^\]]*\])?\{[^}]+\}\n?/g, "");

    // Add packages in correct order after documentclass
    const documentClassMatch = cleaned.match(/(\\documentclass[^\n]*\n)/);
    if (documentClassMatch && packages.length > 0) {
      const insertPoint =
        documentClassMatch.index + documentClassMatch[1].length;
      const orderedPackages = this.orderPackages(packages);
      cleaned =
        cleaned.slice(0, insertPoint) +
        orderedPackages.join("\n") +
        "\n" +
        cleaned.slice(insertPoint);
    }

    // Fix common geometry issues
    cleaned = cleaned.replace(/\\geometry\{([^}]+)\}/g, (match, params) => {
      // Ensure proper parameter format
      return `\\geometry{${params
        .replace(/\s*=\s*/g, "=")
        .replace(/,\s*/g, ",")}}`;
    });

    // Fix section formatting issues
    cleaned = cleaned.replace(
      /\\section\*\{\\LARGE\s+([^}]+)\}/g,
      "\\section*{\\LARGE $1}"
    );
    cleaned = cleaned.replace(
      /\\section\*\{\\Large\s+([^}]+)\}/g,
      "\\section*{\\Large $1}"
    );

    // Ensure proper header formatting
    cleaned = cleaned.replace(
      /\{\\LARGE\s+\\textbf\{([^}]+)\}\}/g,
      "{\\LARGE \\textbf{$1}}"
    );

    // Fix hfill spacing issues
    cleaned = cleaned.replace(
      /\\textbf\{([^}]+)\}\s*\\hfill\s*([^\\\n]+)/g,
      "\\textbf{$1} \\hfill $2"
    );

    // Ensure proper vspace formatting
    cleaned = cleaned.replace(/\\vspace\{(\d+)pt\}/g, "\\vspace{$1pt}");

    // Fix dash formatting for company-location separator - use proper LaTeX commands
    // Convert any remaining em dashes to \textendash{} for consistent PDF output
    cleaned = cleaned.replace(/—/g, "\\textendash{} ");

    // Convert en dashes to \textendash{}
    cleaned = cleaned.replace(/–/g, "\\textendash{} ");

    // Convert double hyphens to \textendash{}
    cleaned = cleaned.replace(/--/g, "\\textendash{} ");

    // Fix missing backslashes in \textendash{} commands
    cleaned = cleaned.replace(/extendash\{\}/g, "\\textendash{}");

    // Fix broken \extendash{} commands (should be \textendash{})
    cleaned = cleaned.replace(/\\extendash\{\}/g, "\\textendash{}");

    // Ensure proper spacing around \textendash{}
    cleaned = cleaned.replace(/\\textendash\{\}\s*/g, " \\textendash{} ");

    // Fix any remaining plain hyphens in separators to use \textendash{} (but be careful not to break email addresses)
    cleaned = cleaned.replace(
      /([A-Za-z0-9])\s*-\s*([A-Za-z0-9])/g,
      (match, before, after) => {
        // Don't replace hyphens in email addresses or URLs
        if (match.includes("@") || match.includes("http")) {
          return match;
        }
        return `${before} \\textendash{} ${after}`;
      }
    );

    // Remove centering commands that break formatting
    cleaned = cleaned.replace(/\\centering\s*/g, "");
    cleaned = cleaned.replace(/\{\\centering\s*([^}]*)\s*\\par\}/g, "$1");
    cleaned = cleaned.replace(/\\begin\{center\}/g, "");
    cleaned = cleaned.replace(/\\end\{center\}/g, "");

    // Fix missing backslashes SAFELY - avoiding issues with double backslashes
    // Only fix at start of lines or after spaces/newlines, never after backslashes
    cleaned = cleaned.replace(/(^|\s|})textbf\{/gm, "$1\\textbf{");
    cleaned = cleaned.replace(/(^|\s|})href\{/gm, "$1\\href{");
    cleaned = cleaned.replace(/(^|\s|})section\*/gm, "$1\\section*");
    cleaned = cleaned.replace(/(^|\s|})begin\{/gm, "$1\\begin{");
    cleaned = cleaned.replace(/(^|\s|})end\{/gm, "$1\\end{");
    cleaned = cleaned.replace(/(^|\s|})item /gm, "$1\\item ");
    cleaned = cleaned.replace(/(^|\s|})vspace\{/gm, "$1\\vspace{");
    cleaned = cleaned.replace(/(^|\s|})setlist\[/gm, "$1\\setlist[");

    // IMPORTANT: Be very careful with double backslashes - they are LaTeX line breaks!
    // Only fix triple or more backslashes, leave double backslashes intact
    cleaned = cleaned.replace(/\\\\\\+/g, "\\\\");

    // Don't touch double backslashes as they are valid LaTeX line breaks (\\)
    // Only fix broken commands that start with \\\ (triple backslash)
    cleaned = cleaned.replace(/\\\\\\([a-zA-Z])/g, "\\$1");

    console.log("✅ LaTeX code cleaned");
    return cleaned;
  }

  /**
   * Order packages to avoid conflicts
   */
  orderPackages(packages) {
    const packageOrder = [
      "latexsym",
      "fullpage",
      "titlesec",
      "marvosym",
      "color",
      "verbatim",
      "enumitem",
      "hyperref",
      "fancyhdr",
      "babel",
      "tabularx",
      "fontawesome",
      "ragged2e",
      "amsmath",
      "amssymb",
      "geometry",
    ];

    const orderedPackages = [];
    const remainingPackages = [...packages];

    // Add packages in preferred order
    packageOrder.forEach((preferredPkg) => {
      const index = remainingPackages.findIndex((pkg) =>
        pkg.includes(`{${preferredPkg}}`)
      );
      if (index !== -1) {
        orderedPackages.push(remainingPackages.splice(index, 1)[0]);
      }
    });

    // Add any remaining packages
    orderedPackages.push(...remainingPackages);

    return orderedPackages;
  }

  async checkDockerAvailability() {
    return new Promise((resolve, reject) => {
      const docker = spawn("docker", ["--version"]);

      docker.on("close", (code) => {
        if (code === 0) {
          resolve(true);
        } else {
          reject(new Error("Docker not available"));
        }
      });

      docker.on("error", (error) => {
        reject(new Error(`Docker check failed: ${error.message}`));
      });

      // Set timeout for the check
      setTimeout(() => {
        docker.kill();
        reject(new Error("Docker check timeout"));
      }, 5000);
    });
  }

  async runDockerLatex(tempDir, filename) {
    return new Promise((resolve) => {
      const docker = spawn("docker", [
        "run",
        "--rm",
        "-v",
        `${tempDir}:/workspace`,
        "resume4-latex-compiler", // Use our custom built image
        "pdflatex",
        "-interaction=nonstopmode",
        `-output-directory=/workspace`,
        `/workspace/${filename}.tex`,
      ]);

      let output = "";
      docker.stdout.on("data", (data) => (output += data.toString()));
      docker.stderr.on("data", (data) => (output += data.toString()));

      docker.on("close", (code) => {
        resolve({
          success: code === 0,
          error: code !== 0 ? output : null,
        });
      });

      docker.on("error", (error) => {
        resolve({
          success: false,
          error: `Docker execution failed: ${error.message}`,
        });
      });
    });
  }

  async cleanupTempFiles(tempDir, filename) {
    const extensions = [
      ".tex",
      ".pdf",
      ".log",
      ".aux",
      ".fls",
      ".fdb_latexmk",
      ".out",
      ".toc",
    ];

    for (const ext of extensions) {
      try {
        await fs.unlink(path.join(tempDir, filename + ext));
      } catch (e) {
        // Ignore cleanup errors
      }
    }
  }

  /**
   * Get available compilation methods
   */
  async getAvailableMethods() {
    const methods = [];

    // Check Docker
    try {
      await this.checkDockerAvailability();
      methods.push({
        method: this.methods.LOCAL_DOCKER,
        quality: "overleaf-equivalent",
        available: true,
        description: "Full LaTeX compilation using Docker container",
      });
    } catch (e) {
      methods.push({
        method: this.methods.LOCAL_DOCKER,
        quality: "overleaf-equivalent",
        available: false,
        reason: "Docker not installed",
        description: "Install Docker to enable this method",
      });
    }

    return methods;
  }

  /**
   * Get service information
   */
  getServiceInfo() {
    return {
      name: "Advanced LaTeX Service",
      version: "1.0.0",
      description: "Multi-method LaTeX compilation with intelligent fallbacks",
      supportedMethods: Object.values(this.methods),
      fallbackOrder: this.fallbackOrder,
    };
  }
}

module.exports = AdvancedLatexService;
